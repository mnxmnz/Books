---
sidebar_position: 15
---

# 15장 웹 브라우저의 자바스크립트

## 15.1 웹 프로그래밍 기본

### 15.1.1 HTML `<script>` 태그 속의 자바스크립트

**`src` 속성의 장점**

- 방대한 자바스크립트 코드를 HTML 파일에서 제거해 단순화한다. 즉, '내용'과 '동작'을 분리한다.
- 여러 개의 웹 페이지에서 같은 자바스크립트 코드를 공유할 때 `src` 속성을 쓰면 코드 하나만 관리해도 된다.
- 자바스크립트 코드를 여러 페이지에서 공유한다면 한 번만 내려받으면 된다. 첫 번째 페이지에서 코드를 내려받으면 다른 페이지는 브라우저 캐시에서 가져올 수 있다.
- `src` 속성은 임의의 URL을 값으로 받으므로 한 서버에 있는 자바스크립트 프로그램이나 웹 페이지가 다른 웹 서버에 있는 코드를 가져올 수 있다. 인터넷 광고는 대부분 이를 바탕으로 만들어진다.

**스크립트 실행 시점: async와 defer**

스크립트의 기본 모드인 동기적 모드가 유일한 모드는 아니다. `<script>` 태그에 `defer`, `async` 속성을 써서 스크립트 실행 방식을 바꿀 수 있다. 이들은 불 속성이며 값은 없으므로 `<script>` 태그에 존재하기만 하면 된다. 단, `src` 속성과 함께 사용해야만 의미가 있다.

- **`defer`**: 문서를 완전히 내려받고 분석해서 조작할 준비가 끝날 때까지 스크립트 실행을 지연(defer)하라는 의미이다.
- **`async`**: 브라우저가 스크립트를 가능한 빨리 실행하되 스크립트를 내려받는 동안 문서 분석을 계속해도 된다는 뜻이다.
- `<script>` 태그에 두 속성 모두 존재한다면 `async` 속성이 우선순위를 갖는다.

`type="module"` 속성이 있는 스크립트는 기본적으로 `defer` 속성이 있는 것처럼 문서 로딩이 끝난 후 실행된다. `async` 속성을 쓰면 문서 로딩이 끝날 때까지 대기하지 않고 가져온 모듈 전부를 불러오는 즉시 실행을 시작한다.

`async`, `defer` 속성을 쓰지 않고 스크립트를 HTML 파일의 마지막에 불러오기만 해도 같은 효과를 볼 수 있다. 브라우저가 문서 로드와 분석을 이미 끝낸 상태이므로 스크립트에서 문서 콘텐츠를 조작해도 안전하다.

**필요에 따른 스크립트 로드**

문서를 처음 불러올 때는 필요가 없지만 사용자가 버튼을 클릭하거나 메뉴를 여는 등 어떤 행동을 했을 때만 필요한 자바스크립트 코드도 있다.

모듈을 사용해 코드를 개발했다면 `import()`를 써서 필요한 모듈만 불러올 수 있다.

모듈을 사용하지 않는다면 스크립트를 불러올 때 문서에 `<script>` 태그를 추가해서 자바스크립트 파일을 불러올 수 있다.

```js
// 지정된 URL에서 비동기적으로 스크립트를 불러와서 실행한다.
// 스크립트를 불러오면 해석되는 프라미스를 반환한다.
function importScript(url) {
  return new Promise((resolve, reject) => {
    let s = document.createElement('script'); // <script> 요소 생성
    s.onload = () => {
      resolve();
    }; // 프라미스 해석
    s.onerror = e => {
      reject(e);
    }; // 실패 시 거부
    s.src = url; // 스크립트 URL 설정
    document.head.append(s); // 문서에 <script> 추가
  });
}
```

### 15.1.2 문서 객체 모델

Document 객체는 브라우저 창이나 탭에 표시되는 HTML 문서를 나타내는 객체이며 클라이언트 사이드 자바스크립트 프로그래밍에서 가장 중요한 객체 중 하나이다.

DOM API는 HTML 문서의 트리 구조를 반영한다. 문서에 존재하는 HTML 태그마다 그에 대응하는 자바스크립트 Element 객체가 있고, 문서에 존재하는 텍스트마다 그에 대응하는 Text 객체가 있다. Element, Text, Document 클래스는 모두 Node 클래스의 서브클래스이며 Node 객체는 트리 구조로 되어 있어, 자바스크립트에서 DOM API를 사용해 검색하고 이동할 수 있다.

### 15.1.3 웹 브라우저의 전역 객체

웹 브라우저에서 전역 객체는 내장 타입과 함수를 정의하기도 하지만 현재 웹 브라우저 창을 나타내기도 하며 그 창의 브라우징 히스토리를 나타내는 `history`, 창의 너비를 픽셀로 나타내는 `innerWidth` 같은 프로퍼티를 정의하기도 한다. 이 전역 객체에는 `window` 프로퍼티가 있으며 그 값은 전역 객체 자체이다.

### 15.1.4 네임스페이스를 공유하는 스크립트

스크립트의 최상위 코드가 상수, 변수, 함수, 클래스를 정의하면 그 선언은 같은 문서에서 실행된 모든 스크립트에서 볼 수 있다. 어떤 스크립트에서 함수 `f()`를 정의하고 다른 스크립트에서 클래스 `c`를 정의하면 세 번째 스크립트에서는 그들을 가져오지 않고도 함수를 호출하고 클래스의 인스턴스를 만들 수 있다.

최상위 레벨에서 `var`, `function` 선언을 사용하면 공유된 전역 객체에 프로퍼티가 생성된다. 스크립트 최상위 함수 `f()`를 정의하면 같은 문서에 있는 다른 스크립트는 그 함수를 `f()`로도, `window.f()`로도 호출할 수 있다. ES6의 `const`, `let`, `class`는 최상위 레벨에서 사용하더라도 전역 객체가 아니라 공유된 네임스페이스 안에 생성된다. 스크립트에서 클래스 `C`를 정의하면 다른 스크립트에서는 `new window.C()`가 아니라 `new C()`로 그 클래스의 인스턴스를 만든다.

### 15.1.5 자바스크립트 프로그램 실행

**클라이언트 사이드 자바스크립트 스레드 모델**

자바스크립트는 싱글 스레드 언어이며, 싱글 스레드 실행 모델은 두 이벤트 핸들러가 절대 동시에 실행되지 않으므로 프로그래밍이 훨씬 단순하다. 콘텐츠를 수정할 때 다른 스레드가 같은 콘텐츠를 동시에 수정하게 될 일도 없고, 락(lock), 교착 상태(deadlock), 경합 조건(rece condition)을 걱정할 필요도 없다.

싱글 스레드는 웹 브라우저가 스크립트와 이벤트 핸들러를 실행하는 동안 사용자 입력에 반응하지 않는다는 의미이다. 따라서 자바스크립트 프로그래머는 스크립트와 이벤트 핸들러가 너무 오래 실행되게 만들어서는 안 된다. 스크립트에서 과도한 계산을 수행하면 문서 로딩이 지연되고 사용자는 스크립트 실행이 완료될 때까지 문서 콘텐츠를 볼 수 없다. 이벤트 핸들러에서 과도한 계산을 수행하면 브라우저의 응답이 멈추고 사용자는 브라우저가 다운됐다고 생각할 수도 있다.

웹 플랫폼은 '웹 워커'를 통해 동시성을 구현한다. 웹 워커는 사용자 인터페이스를 멈추지 않으면서 실행되는 백그라운드 스레드이다. 웹 워커 스레드에서 실행되는 코드는 문서 콘텐츠에 접근할 수 없고, 메인 스레드나 다른 워커와는 상태를 공유하지 않으면서 오로지 비동기 메시지 이벤트를 통해서만 통신한다.

<br />

## 15.2 이벤트

**이벤트 타입**

이벤트 종류를 지정하는 문자열이다. 예를 들어 `mousemove` 타입은 사용자가 마우스를 움직였다는 의미이다. `keydown` 타입은 사용자가 키보드의 키를 눌렀다는 뜻이다. `load` 타입은 문서나 기타 자원의 로딩이 끝났다는 의미이다. 이벤트 타입은 단순한 문자열이므로 이벤트 이름이라 부를 때도 있다.

**이벤트 대상**

이벤트가 일어난, 또는 이벤트와 연관된 객체이다. 이벤트를 지칭할 때는 'Window 객체의 `load` 이벤트'나 '`<button>` 요소의 `click` 이벤트'처럼 반드시 그 타입과 대상을 함께 지정해야 한다.

**이벤트 핸들러 또는 이벤트 리스너**

이 함수는 이벤트를 처리하거나 이벤트에 반응한다. 애플리케이션은 이벤트 타입과 이벤트 대상을 지정해 웹 브라우저에 이벤트 핸들러 함수를 등록한다.

<br />

## 15.3 문서 스크립트

### 15.3.4 요소 콘텐츠

요소의 `innerHTML` 프로퍼티는 요소 콘텐츠를 마크업 문자열로 반환한다. 이 프로퍼티의 값을 설정하면 웹 브라우저 파서를 호출해서 요소의 현재 콘텐츠를 새로운 문자열을 분석한 값으로 교체한다.

`outerHTML` 프로퍼티는 `innerHTML`과 비슷하지만 그 값에 요소 자체가 포함된다는 점이 다르다. `outerHTML`의 값에는 요소를 열고 닫는 태그가 포함된다. `outerHTML`을 설정하면 요소 자체가 새로운 콘텐츠로 교체된다.

관련된 메서드 `insertAdjacentHTML()`은 지정된 요소에 '인접한(adjacent)' 위치에 임의의 HTML 마크업을 삽입한다. 마크업은 두 번재 인자이며 '인접한'의 정확한 의미는 첫 번째 인자에 따라 다르다. 첫 번째 인자는 반드시 `beforebegin`, `afterbegin`, `beforeend`, `afterend` 중 하나의 문자열이어야 한다.

```html
"beforebegin"
<div id="target">"afterbegin"This is the element content"beforeend"</div>
"afterend"
```

<br />

<hr />

JavaScript: The Definitive Guide, Seventh Edition, by David Flanagan (O'Really). Copyright 2020 David Flanagan, 978-1-491-95202-3
